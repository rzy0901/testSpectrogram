function H = scatteringchanmtx(txarraypos_in,rxarraypos_in,txang_in,rxang_in,g_in)
%SCATTERINGCHANMTX    Scattering based MIMO channel matrix
%   HCHAN = scatteringchanmtx(TXARRAYPOS,RXARRAYPOS,NS) returns the channel
%   matrix, HCHAN, for a MIMO channel consists of a transmit array
%   specified in TXARRAYPOS, a receive array specified in RXARRAYPOS, and
%   NS point scatterers. NS must be a positive integer.
%
%   The function randomly select NS directions for transmit array and NS
%   directions for receive array. Signal leaves the transmit array, bounced
%   off each scatterers, and then arrive at the receive array. Therefore,
%   the channel matrix contains multipath propagation through NS paths. It
%   is assumed that all paths arrive at the receive array simultaneously so
%   the channel is frequency flat. The path gain for all paths are
%   generated by randomly sampling a complex, zero mean, and unit variance
%   normal distribution.
% 
%   TXARRAYPOS and RXARRAYPOS represent the locations of elements relative
%   to the array's phase center in the transmit and receive sensor arrays,
%   respectively. The positions are specified in the unit of signal
%   wavelength. All elements in the sensor array are assumed to be
%   isotropic.
%   
%   TXARRAYPOS can be either a 1xNt vector, a 2xNt matrix, or a 3xNt
%   matrix, where Nt is the number of elements in the transmit array.
%
%   If TXARRAYPOS is a 1xNt vector, then it represents y-coordinates of
%   elements in a linear array that is along the y axis.
%
%   If TXARRAYPOS is a 2xNt matrix, then the array lies in the yz plane. In
%   this case, each column of TXARRAYPOS represents the [y;z] coordinates
%   of the corresponding element.
%
%   If TXARRAYPOS is a 3xNt matrix, then the array has arbitrary shape. In
%   this case, each column of TXARRAYPOS represents the [x;y;z] coordinates
%   of the corresponding element.
%   
%   RXARRAYPOS can be either a 1xNr vector, a 2xNr matrix, or a 3xNr
%   matrix, where Nr is the number of elements in the receive array.
%
%   If RXARRAYPOS is a 1xNr vector, then it represents y-coordinates of
%   elements in a linear array that is along the y axis.
%
%   If RXARRAYPOS is a 2xNr matrix, then the array lies in the yz plane. In
%   this case, each column of RXARRAYPOS represents the [y;z] coordinates
%   of the corresponding element.
%
%   If RXARRAYPOS is a 3xNr matrix, then the array has arbitrary shape. In
%   this case, each column of RXARRAYPOS represents the [x;y;z] coordinates
%   of the corresponding element.
%
%   The channel matrix, HCHAN, has a size of NtxNr.
%
%   HCHAN = scatteringchanmtx(TXARRAYPOS,RXARRAYPOS,NS,ANGRANGE) specifies
%   the transmit and receive angle sector (in degrees) in ANGRANGE.
%   ANGRANGE can be row vector with 2, or 4 elements or a 2-row matrix with
%   2, or 4 columns.
%
%   If ANGRANGE is a row vector with 2 elements, it specifies the range of
%   angle in the form of [az_min az_max]. Azimuth angles for both transmit
%   and receive are sampled within the specified interval and the elevation
%   angle is sampled between -90 and 90 degrees.
%
%   If ANGRANGE is a row vector with 4 elements, it specifies the range of
%   angles in the form of [tx_az_min tx_az_max rx_az_min rx_az_max] where
%   the azimuth angle for transmit array is sampled from the [tx_az_min
%   tx_az_max] interval and the azimuth angle for receive array is sampled
%   from the [rx_az_min rx_az_max] interval.
%
%   If ANGRANGE is a 2-row matrix, the first row specifies the range of
%   azimuth angles as in the row vector case. The second row of ANGRANGE
%   then specifies the range of elevation angles in the form of either
%   [el_min el_max] or [tx_el_min tx_el_max rx_el_min rx_el_max].
%
%   HCHAN = scatteringchanmtx(TXARRAYPOS,RXARRAYPOS,TXANG,RXANG,G)
%   specifies the transmit angles (in degrees), receive angles (in
%   degrees), and path gains in TXANG, RXANG, and G respectively. TXANG can
%   be either a 1xNS vector or 2xNS matrix where NS is the number of
%   scatterers.
%
%   If TXANG is a vector, each element in TXANG specifies the azimuth angle
%   of the corresponding path and the elevation angle of that path are set
%   to 0.
%
%   If TXANG is a matrix, each column in TXANG specifies the angle of the
%   corresponding path in the form of [az; el]. 
%
%   RXANG use the same convention as TXANG except it specifies the receive
%   angle. G is a 1xNS vector whose elements specify the path gains for
%   each propagation path.
%
%   % Examples:
%
%   % Example 1:
%   %   Simulate a 16x12 MIMO channel with 20 scatterers, then compute the
%   %   propagated signal from the input signal. Assume the arrays are 
%   %   uniform linear arrays with half wavelength spacing.
%
%   Nt = 16; 
%   txpos = (0:Nt-1)*0.5;
%   Nr = 12;
%   rxpos = (0:Nr-1)*0.5;
%   Ns = 20;
%   H = scatteringchanmtx(txpos,rxpos,Ns);
%   
%   x = randi(2,[100 Nt])-1;
%   y = x*H;
%
%   % Example 2:
%   %   Simulate a 12x32 MIMO channel with only direct path, then compute 
%   %   the propagated signal from the input signal. Assume the transmit 
%   %   array is a 12-element circular array with a radius of 3 wavelength
%   %   and the receive array is a 4x8 URA. The transmit array is at the 
%   %   [0;0;50] meters and the receive array is at [200;0;0] meters.
%
%   % transmit and receive array
%   Nt = 12;
%   R = 3;
%   txpos = [R*cosd((0:Nt-1)/Nt*360);R*sind((0:Nt-1)/Nt*360);zeros(1,Nt)];
%   Nr = 32;
%   [ypos,zpos] = meshgrid((-3.5:3.5)*0.5,(-1.5:1.5)*0.5);
%   rxpos = [zeros(1,Nr);ypos(:).';zpos(:).'];
%
%   % transmit and receive angle
%   txcenter = [0;0;50];
%   rxcenter = [200;0;0];
%   [~,txang] = rangeangle(rxcenter,txcenter);
%   [~,rxang] = rangeangle(txcenter,rxcenter);
%   g = 1;
%
%   H = scatteringchanmtx(txpos,rxpos,txang,rxang,g);
%   
%   x = randi(2,[100 Nt])-1;
%   y = x*H;
%
%   See also phased, phased.ScatteringMIMOChannel

%   Copyright 2016-2017 The MathWorks, Inc.

%   References
%   [1] Robert Heath Jr. et al. An Overview of Signal Processing
%   Techniques for Millimeter Wave MIMO Systems
%   [2] David Tse and Pramod Viswanath, Fundamentals of Wireless
%   Communications, Cambridge, 2005
%   [3] Arogyswami Paulraj, Introduction to Space-Time Wireless
%   Communication, Cambridge, 2003

%#codegen
%#ok<*EMCA>
    
narginchk(3,5);

if size(txarraypos_in,1) == 1
    txarraypos = [zeros(1,size(txarraypos_in,2));txarraypos_in;zeros(1,size(txarraypos_in,2))];
elseif size(txarraypos_in,1) == 2
    txarraypos = [zeros(1,size(txarraypos_in,2));txarraypos_in];
else
    txarraypos = txarraypos_in;
end
sigdatatypes.validate3DCartCoord(txarraypos,'scatteringchanmtx','TXARRAYPOS');

if size(rxarraypos_in,1) == 1
    rxarraypos = [zeros(1,size(rxarraypos_in,2));rxarraypos_in;zeros(1,size(rxarraypos_in,2))];
elseif size(rxarraypos_in,1) == 2
    rxarraypos = [zeros(1,size(rxarraypos_in,2));rxarraypos_in];
else
    rxarraypos = rxarraypos_in;
end
sigdatatypes.validate3DCartCoord(rxarraypos,'scatteringchanmtx','RXARRAYPOS');

if nargin == 3
    N = txang_in;
    sigdatatypes.validateIndex(N,'scatteringchanmtx','NS',{'scalar'});
    txang = [360*rand(1,N)-180;180*rand(1,N)-90];
    rxang = [360*rand(1,N)-180;180*rand(1,N)-90];
    g = 1/sqrt(2)*complex(randn(1,N),randn(1,N));
elseif nargin == 4
    N = txang_in;
    sigdatatypes.validateIndex(N,'scatteringchanmtx','NS',{'scalar'});
    
    angspan_in = rxang_in;
    sigdatatypes.validateAngle(angspan_in,'scatteringchanmtx','ANGRANGE',{'2d'});
    cond = ~(size(angspan_in,2)==2 || size(angspan_in,2)==4);
    if cond
        coder.internal.errorIf(cond,'phased:phased:expectedNumCols','ANGRANGE','2 4');
    end
    cond = (size(angspan_in,1)>2);
    if cond
        coder.internal.errorIf(cond,'phased:phased:expectedNumRows','ANGRANGE','1 2');
    end
    if size(angspan_in,2) == 2
        cond = any(angspan_in(:,1)>angspan_in(:,2));
        if cond
            coder.internal.errorIf(cond,'phased:phased:expectedNondecreasingRows','ANGRANGE');
        end
        angspan = repmat(angspan_in,1,2);
    else %size(angspan_in,2) == 4
        cond = (any(angspan_in(:,1)>angspan_in(:,2)) || ...
            any(angspan_in(:,3)>angspan_in(:,4)));
        if cond
            coder.internal.errorIf(cond,'phased:phased:expectedNondecreasingRange');
        end
        angspan = angspan_in;
    end
    txazrange = angspan(1,1:2);
    rxazrange = angspan(1,3:4);
    if size(angspan,1)==1
        txelrange = [-90 90];
        rxelrange = [-90 90];
    else
        txelrange = angspan(2,1:2);
        rxelrange = angspan(2,3:4);
    end
    sigdatatypes.validateAzElAngle([txazrange rxazrange;txelrange rxelrange],...
        'scatteringchanmtx','ANGRANGE');
    txang = [diff(txazrange)*rand(1,N)+txazrange(1);...
        diff(txelrange)*rand(1,N)+txelrange(1)];
    rxang = [diff(rxazrange)*rand(1,N)+rxazrange(1);...
        diff(rxelrange)*rand(1,N)+rxelrange(1)];
    g = 1/sqrt(2)*complex(randn(1,N),randn(1,N));
else
    if size(txang_in,1)==1
        txang = [txang_in;zeros(size(txang_in))];
    else
        txang = txang_in;
    end
    sigdatatypes.validateAzElAngle(txang,'scatteringchanmtx','TXANG');
    
    if size(rxang_in,1)==1
        rxang = [rxang_in;zeros(size(rxang_in))];
    else
        rxang = rxang_in;
    end
    sigdatatypes.validateAzElAngle(rxang,'scatteringchanmtx','RXANG');
    
    cond = (size(txang,2)~=size(rxang,2));
    if cond
        coder.internal.errorIf(cond,'phased:phased:NumColumnsMismatch','TXANG','RXANG');
    end
    
    g = g_in;
    validateattributes(g,{'double'},{'nonempty','finite','nonnan','size',[1 size(txang,2)]},...
        'scatteringchanmtx','G');
end

Htemp = bsxfun(@times,g,...
    steervec(rxarraypos,rxang))*steervec(txarraypos,txang).';

H = Htemp.';  % Nt x Nr
    
